package com.hedera.mirror.parser.record;

/*-
 * ‌
 * Hedera Mirror Node
 * ​
 * Copyright (C) 2019 Hedera Hashgraph, LLC
 * ​
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ‍
 */

import java.io.DataInputStream;
import java.nio.ByteBuffer;

import com.fasterxml.jackson.databind.util.ByteBufferBackedInputStream;
import com.google.common.base.Stopwatch;
import com.google.protobuf.TextFormat;
import com.hedera.mirror.domain.ApplicationStatusCode;
import com.hedera.mirror.domain.StreamItem;
import com.hedera.mirror.repository.ApplicationStatusRepository;
import com.hedera.filedelimiters.FileDelimiter;
import com.hedera.recordFileLogger.RecordFileLogger;
import com.hedera.recordFileLogger.RecordFileLogger.INIT_RESULT;
import com.hedera.utilities.Utility;
import com.hederahashgraph.api.proto.java.Transaction;
import com.hederahashgraph.api.proto.java.TransactionRecord;
import javassist.NotFoundException;
import lombok.extern.log4j.Log4j2;
import org.apache.commons.codec.binary.Hex;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHandler;
import org.springframework.messaging.MessagingException;

import javax.inject.Named;

/**
 * This is a utility file to read back service record file generated by Hedera node
 */
@Log4j2
@Named("RecordFileParser")
public class RecordFileParser implements MessageHandler {

	private final ApplicationStatusRepository applicationStatusRepository;

	public RecordFileParser(ApplicationStatusRepository applicationStatusRepository, RecordParserProperties parserProperties) {
		this.applicationStatusRepository = applicationStatusRepository;
		RecordFileLogger.parserProperties = parserProperties;
	}

	/**
	 * Given a service record name, read and parse and return as a list of service record pair
	 *
	 * @param streamItem
	 * 		the streamItem of record type
	 * @return return boolean indicating method success
	 */
	private boolean loadRecordFile(StreamItem streamItem) {
	    final String fileName = streamItem.getFileName();
        String previousFileHash = applicationStatusRepository.findByStatusCode(ApplicationStatusCode.LAST_PROCESSED_RECORD_HASH);
        String thisFileHash = Hex.encodeHexString(Utility.getStreamItemHash(streamItem));

		long counter = 0;
		byte[] readFileHash = new byte[48];
		INIT_RESULT initFileResult = RecordFileLogger.initFile(fileName);
		Stopwatch stopwatch = Stopwatch.createStarted();

		if (initFileResult == INIT_RESULT.OK) {
			try (DataInputStream dis = new DataInputStream(new ByteBufferBackedInputStream(streamItem.getDataBytes().rewind()))) {
				int record_format_version = dis.readInt();
				int version = dis.readInt();

				log.info("Loading version {} record file: {}", record_format_version, fileName);

				while (dis.available() != 0) {

					try {
						byte typeDelimiter = dis.readByte();

						switch (typeDelimiter) {
							case FileDelimiter.RECORD_TYPE_PREV_HASH:
								dis.read(readFileHash);

								if (Utility.hashIsEmpty(previousFileHash)) {
									log.error("Previous file hash not available");
									previousFileHash = Hex.encodeHexString(readFileHash);
								}

								String newFileHash = Hex.encodeHexString(readFileHash);

								log.trace("New file hash = {}, old hash = {}", newFileHash, previousFileHash);

								if (!newFileHash.contentEquals(previousFileHash)) {

									if (applicationStatusRepository.findByStatusCode(ApplicationStatusCode.RECORD_HASH_MISMATCH_BYPASS_UNTIL_AFTER).compareTo(Utility.getFileName(fileName)) < 0) {
										// last file for which mismatch is allowed is in the past
										log.error("Hash mismatch for file {}. Previous = {}, Current = {}", fileName, previousFileHash, newFileHash);
										RecordFileLogger.rollback();
										return false;
									}
								}
								break;
							case FileDelimiter.RECORD_TYPE_RECORD:
								counter++;

								int byteLength = dis.readInt();
								byte[] rawBytes = new byte[byteLength];
								dis.readFully(rawBytes);
								Transaction transaction = Transaction.parseFrom(rawBytes);

								byteLength = dis.readInt();
								rawBytes = new byte[byteLength];
								dis.readFully(rawBytes);

								TransactionRecord txRecord = TransactionRecord.parseFrom(rawBytes);
								RecordFileLogger.storeRecord(transaction, txRecord);

								if (log.isTraceEnabled()) {
									log.trace("Transaction = {}, Record = {}", Utility.printTransaction(transaction), TextFormat.shortDebugString(txRecord));
								} else {
									log.debug("Stored transaction with consensus timestamp {}", txRecord.getConsensusTimestamp());
								}
								break;
							case FileDelimiter.RECORD_TYPE_SIGNATURE:
								int sigLength = dis.readInt();
								byte[] sigBytes = new byte[sigLength];
								dis.readFully(sigBytes);
								log.trace("File {} has signature {}", fileName, Hex.encodeHexString(sigBytes));
								break;

							default:
								log.error("Unknown record file delimiter {} for file {}", typeDelimiter, fileName);
								RecordFileLogger.rollback();
								return false;
						}
					} catch (Exception e) {
						log.error("Exception {}", e);
						RecordFileLogger.rollback();
						return false;
					}
				}

				log.trace("Calculated file hash for the current file {}", thisFileHash);

				RecordFileLogger.completeFile(thisFileHash, previousFileHash);
			} catch (Exception e) {
				log.error("Error parsing record file {} after {}", fileName, stopwatch, e);
				RecordFileLogger.rollback();
				return false;
			}

			log.info("Finished parsing {} transactions from record file {} in {}", counter, fileName, stopwatch);
			if (!Utility.hashIsEmpty(thisFileHash)) {
				applicationStatusRepository.updateStatusValue(ApplicationStatusCode.LAST_PROCESSED_RECORD_HASH, thisFileHash);
			}
            applicationStatusRepository.updateStatusValue(ApplicationStatusCode.LAST_PROCESSED_RECORD_FILENAME, fileName);
            return true;
		} else if (initFileResult == INIT_RESULT.SKIP) {
			return true;
		} else {
			RecordFileLogger.rollback();
			return false;
		}
	}

    @Override
    public void handleMessage(Message<?> message) throws MessagingException {
	    StreamItem streamItem = (StreamItem) message.getPayload();
        log.debug("Processing {}", streamItem);
		try {
			if (RecordFileLogger.start()) {
                boolean result = loadRecordFile(streamItem);
                // TODO; halt processing if result is false.
				RecordFileLogger.finish();
			}
		} catch (Exception e) {
			log.error("Error parsing {}", streamItem, e);
		}
	}

    /**
     * Given a record stream file data, read its prevFileHash
     * @return return previous file hash's Hex String
     */
    public static String readPrevFileHash(ByteBuffer data) throws NotFoundException {
        byte[] prevFileHash = new byte[48];
        try {
            // record_format_version
            data.getInt();

            // version
            data.getInt();

            byte typeDelimiter = data.get();

            if (typeDelimiter == FileDelimiter.RECORD_TYPE_PREV_HASH) {
                data.get(prevFileHash);
                return Hex.encodeHexString(prevFileHash);
            } else {
                throw new NotFoundException("Expecting previous file hash, but found file delimiter " + typeDelimiter);
            }
        } catch (Exception e) {
            throw new NotFoundException("Error reading previous file hash", e);
        }
    }
}
